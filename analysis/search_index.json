[["index.html", "The Earth Hologenome Initiative Data Analysis Workflow Chapter 1 Introduction 1.1 Prepare the R environment 1.2 Download mock data", " The Earth Hologenome Initiative Data Analysis Workflow Ostaizka Aizpurua1 Antton Alberdi2 2023-11-06 Chapter 1 Introduction The Earth Hologenome Initiative (EHI, www.earthhologenome.org) is a global collaborative endeavour aimed at promoting, facilitating, coordinating, and standardising hologenomic research on wild organisms worldwide. The EHI encompasses projects with diverse study designs and goals around standardised and open access sample collection and preservation, data generation and data management criteria. One of the main objectives of the EHI is to facilitate analysis of animal genomic and microbial metagenomic data. Here, you will find resources to summarise, visualise and model data generated through the EHI pipeline. 1.1 Prepare the R environment The first step is to prepare your R environment. You must ensure you are at the appropriate working directory, and all required libraries are installed and loaded. setwd(&quot;path_to_your_working_directory&quot;) # Change this to your absolute working directory dir_create(&quot;data&quot;) #Create the data folder to store EHI data files The pipeline requires the following packages to be installed in your R environment. # These packages can be installed from CRAN install.packages(&quot;R.utils&quot;) install.packages(&quot;knitr&quot;) install.packages(&quot;tidyverse&quot;) install.packages(&quot;ape&quot;) install.packages(&quot;phytools&quot;) install.packages(&quot;ggplot2&quot;) install.packages(&quot;ggtree&quot;) install.packages(&quot;ggrepel&quot;) install.packages(&quot;ggpubr&quot;) install.packages(&quot;ggnewscale&quot;) install.packages(&quot;ggtreeExtra&quot;) install.packages(&quot;gridExtra&quot;) install.packages(&quot;spaa&quot;) install.packages(&quot;vegan&quot;) install.packages(&quot;Rtsne&quot;) install.packages(&quot;devtools&quot;) # This packages must be installed from Github using devtools library(devtools) install_github(&quot;anttonalberdi/hilldiv2&quot;) All those packages then need to be loaded to your R environment. suppressPackageStartupMessages(library(R.utils)) suppressPackageStartupMessages(library(knitr)) suppressPackageStartupMessages(library(tidyverse)) suppressPackageStartupMessages(library(ape)) suppressPackageStartupMessages(library(phytools)) suppressPackageStartupMessages(library(ggplot2)) suppressPackageStartupMessages(library(ggtree)) suppressPackageStartupMessages(library(ggrepel)) suppressPackageStartupMessages(library(ggpubr)) suppressPackageStartupMessages(library(ggnewscale)) suppressPackageStartupMessages(library(ggtreeExtra)) suppressPackageStartupMessages(library(gridExtra)) suppressPackageStartupMessages(library(hilldiv2)) suppressPackageStartupMessages(library(spaa)) suppressPackageStartupMessages(library(vegan)) suppressPackageStartupMessages(library(Rtsne)) 1.2 Download mock data If you want to reproduce the analyses shown in this website, you can download the mock data. # Count table download.file( &quot;https://github.com/earthhologenome/EHI_analysis/raw/main/data/DMB0038_counts.tsv.gz&quot;, &quot;data/DMB0038_counts.tsv.gz&quot;) # Coverage table download.file( &quot;https://github.com/earthhologenome/EHI_analysis/raw/main/data/DMB0038_coverage.tsv.gz&quot;, &quot;data/DMB0038_coverage.tsv.gz&quot;) # MAG metadata table download.file( &quot;https://github.com/earthhologenome/EHI_analysis/raw/main/data/DMB0038_mag_info.tsv.gz&quot;, &quot;data/DMB0038_mag_info.tsv.gz&quot;) # Sample metadata table download.file( &quot;https://github.com/earthhologenome/EHI_analysis/raw/main/data/DMB0038_metadata.tsv.gz&quot;, &quot;data/DMB0038_metadata.tsv.gz&quot;) # MAG phylogenetic tree download.file( &quot;https://github.com/earthhologenome/EHI_analysis/raw/main/data/DMB0038.tree.gz&quot;, &quot;data/DMB0038.tree.gz&quot;) # MAG functional annotation table download.file( &quot;https://github.com/earthhologenome/EHI_analysis/raw/main/data/DMB0038_merged_kegg.tsv.gz&quot;, &quot;data/DMB0038_merged_kegg.tsv.gz&quot;) Now you are ready to begin your analysis. University of Copenhagen, ostaizka.aizpurua@sund.ku.dk↩︎ University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["data-summary.html", "Chapter 2 Data summary 2.1 Load the data 2.2 General data statistics 2.3 General MAG statistics 2.4 Geographic distribution 2.5 Prepare the colour layout", " Chapter 2 Data summary 2.1 Load the data The EHI pipeline outputs six data files in analysis batches. Each batch is assigned a batch code in the form of DMB1234. DMB stands for Dereplication &amp; Mapping Batch, which is the final step of the EHI pipeline. The six output files are: Microbiome count table ([BATCH]_counts.tsv.gz): this is a contingency table containing the number of sequencing reads from each sample mapped against each MAG, with MAG identifiers in rows and sample identifiers in columns. Microbiome coverage table ([BATCH]_coverage.tsv.gz): it has the same structure as the count table, but contains breadth-of-coverage information of each MAG in each sample. In other words, it contains the fraction of the genomes covered by mapped reads in each sample. Sample metadata table ([BATCH]_metadata.tsv.gz): it contains relevant metadata of the samples, including geographic origin, host species, sample type and statistics of sample preprocessing. Microbiome metadata table ([BATCH]_mag_info.tsv.gz): it contains relevant metadata of the MAGs, including taxonomy, genome completeness, contamination/redundancy and other quality metrics. Microbiome phylogenetic tree ([BATCH].tree.gz): this is the phylogenetic tree of the MAGs derived from the GTDB master tree after pruning all reference genomes. This file is used for phylogenetic analyses. Microbiome functional attribute table ([BATCH]_merged_kegg.tsv.gz): this is a contingency table containing the fullness levels of hundreds of KEGG modules, with MAG identifiers in rows and KEGG module identifiers in columns. This table is used for functional analyses. You first need to download these documents from the server, using the links in the EHI data report. In this workflow, we assume the files are downloaded to the folder “data” in your working environment. # Batch batch=&quot;DMB0038&quot; # Microbiome count table count_table &lt;- read.table( gunzip(paste0(&quot;data/&quot;,batch,&quot;_counts.tsv.gz&quot;), remove=FALSE, overwrite=TRUE), sep=&quot;\\t&quot;,row.names=1,header=T) # Microbiome coverage table coverage_table &lt;- read.table( gunzip(paste0(&quot;data/&quot;,batch,&quot;_coverage.tsv.gz&quot;), remove=FALSE, overwrite=TRUE), sep=&quot;\\t&quot;,row.names=1,header=T) # Sample metadata table sample_table &lt;- read.table( gunzip(paste0(&quot;data/&quot;,batch,&quot;_metadata.tsv.gz&quot;), remove=FALSE, overwrite=TRUE), sep=&quot;\\t&quot;,header=T) %&gt;% rename(sample=EHI_plaintext) # rename column # Microbiome metadata table mags_table &lt;- read.table( gunzip(paste0(&quot;data/&quot;,batch,&quot;_mag_info.tsv.gz&quot;), remove=FALSE, overwrite=TRUE), sep=&quot;\\t&quot;,header=T) rownames(mags_table) &lt;- mags_table[,1] # add row names # Microbiome phylogenetic tree tree &lt;- read.tree( gunzip(paste0(&quot;data/&quot;,batch,&quot;.tree.gz&quot;), remove=FALSE, overwrite=TRUE)) # Microbiome functional attribute table kegg_table &lt;- read.table( gunzip(paste0(&quot;data/&quot;,batch,&quot;_merged_kegg.tsv.gz&quot;), remove=FALSE, overwrite=TRUE), sep=&quot;\\t&quot;,header=T, row.names=1) 2.2 General data statistics You can then generate some general statistics to obtain an overview of your data. Number of samples ncol(count_table) [1] 38 Amount of discarded data The value is in GBs (gigabases) sum(round(((sample_table$metagenomic_bases+sample_table$host_bases)/(1-sample_table$bases_lost_fastp_percent))-(sample_table$metagenomic_bases+sample_table$host_bases)))/1000000000 [1] 6.410973 Amount of host data The value is in GBs (gigabases) sum(sample_table$host_bases)/1000000000 [1] 7.046948 Amount of metagenomic data The value is in GBs (gigabases) sum(sample_table$metagenomic_bases)/1000000000 [1] 133.1334 Amount of estimated prokaryotic sum(sample_table$metagenomic_bases * sample_table$singlem_fraction)/1000000000 [1] 88.89506 2.3 General MAG statistics Number of MAGs nrow(count_table) [1] 581 Number of MAGs without species-level annotation These are the MAGs that could be considered “new” species mags_table %&gt;% filter(species == &quot;s__&quot;) %&gt;% nrow() [1] 521 2.3.1 Number of phylums mags_table %&gt;% select(phylum) %&gt;% unique() %&gt;% pull() %&gt;% length() [1] 17 2.4 Geographic distribution You can visualise the origin of your samples using the geographic information available in the sample metadata table. First you need to generate summary information containing unique sampling sites and the number of samples per site. #Summarise for generating map options(dplyr.summarise.inform = FALSE) sample_table_summary &lt;- sample_table %&gt;% #Group by geography and count samples select(sample, latitude, longitude, country) %&gt;% group_by(latitude, longitude) %&gt;% summarize(count = n()) %&gt;% ungroup() Then, this new table can be used to generate the map with location shape sizes indicating the number of samples. sample_table_summary %&gt;% ggplot(.) + #render map geom_map( data=map_data(&quot;world&quot;), map = map_data(&quot;world&quot;), aes(long, lat, map_id=region), color = &quot;white&quot;, fill = &quot;#cccccc&quot;, linewidth = 0.2 ) + #render points geom_point( aes(x=longitude,y=latitude, size=count), alpha=0.5, shape=16) + #add general plot layout theme_minimal() + theme(legend.position = &quot;none&quot;, axis.title.x=element_blank(), axis.title.y=element_blank() ) You can also plot the summary table. sample_table %&gt;% select(sample,sample_type,region,country,latitude,longitude) %&gt;% kable() sample sample_type region country latitude longitude EHI00678 Faecal San Salvador Bahamas 24.05862 -74.46739 EHI00682 Faecal Chub Cay Bahamas 25.40986 -77.87054 EHI00743 Faecal Cockpit Jamaica 18.38248 -77.51726 EHI00679 Faecal Chub Cay Bahamas 25.40986 -77.87054 EHI00674 Faecal Cockpit Jamaica 18.38248 -77.51726 EHI00689 Faecal Andros Bahamas 24.66547 -77.80168 EHI00688 Faecal Acklins Bahamas 22.65397 -73.93493 EHI00690 Faecal Andros Bahamas 24.66547 -77.80168 EHI00692 Faecal Andros Bahamas 24.66547 -77.80168 EHI00753 Faecal Chub Cay Bahamas 25.40986 -77.87054 EHI00696 Faecal Grand Cayman Cayman Islands 19.32504 -81.20698 EHI00751 Faecal Cockpit Jamaica 18.38248 -77.51726 EHI00680 Faecal San Salvador Bahamas 24.05862 -74.46739 EHI00683 Faecal San Salvador Bahamas 24.05862 -74.46739 EHI00732 Faecal Soroa Cuba 22.77456 -83.03659 EHI00695 Faecal Grand Cayman Cayman Islands 19.32504 -81.20698 EHI00693 Faecal Andros Bahamas 24.66547 -77.80168 EHI00731 Faecal Acklins Bahamas 22.65397 -73.93493 EHI00675 Faecal Cockpit Jamaica 18.38248 -77.51726 EHI00686 Faecal Acklins Bahamas 22.65397 -73.93493 EHI00681 Faecal San Salvador Bahamas 24.05862 -74.46739 EHI00758 Faecal Soroa Cuba 22.77456 -83.03659 EHI00685 Faecal Acklins Bahamas 22.65397 -73.93493 EHI00752 Faecal Chub Cay Bahamas 25.40986 -77.87054 EHI00697 Faecal Grand Cayman Cayman Islands 19.32504 -81.20698 EHI00742 Faecal Cockpit Jamaica 18.38248 -77.51726 EHI00698 Faecal Grand Cayman Cayman Islands 19.32504 -81.20698 EHI00687 Faecal Acklins Bahamas 22.65397 -73.93493 EHI00684 Faecal Acklins Bahamas 22.65397 -73.93493 EHI00733 Faecal Soroa Cuba 22.77456 -83.03659 EHI00691 Faecal Andros Bahamas 24.66547 -77.80168 EHI00757 Faecal Chub Cay Bahamas 25.40986 -77.87054 EHI00699 Faecal Grand Cayman Cayman Islands 19.32504 -81.20698 EHI00677 Faecal San Salvador Bahamas 24.05862 -74.46739 EHI00700 Faecal Grand Cayman Cayman Islands 19.32504 -81.20698 EHI00730 Faecal Chub Cay Bahamas 25.40986 -77.87054 EHI00694 Faecal Andros Bahamas 24.66547 -77.80168 EHI00676 Faecal Cockpit Jamaica 18.38248 -77.51726 2.5 Prepare the colour layout For the sake of consistency through EHI projects, we have created a unified colour profile for bacterial and archaeal taxa. The palette assign similar colours to closely related phyla, and more distinct hues to distantly related phyla. The colour profile can be downloaded from Github, and store as an object in R for downstream analyses. https://github.com/earthhologenome/EHI_taxonomy_colour/edit/main/README.md # Download and load the phylum colour table colours_URL=&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot; download.file(colours_URL, &quot;data/ehi_phylum_colors.tsv&quot;) ehi_phylum_colors &lt;- read.table(&quot;data/ehi_phylum_colors.tsv&quot;,sep=&quot;\\t&quot;,header=T,comment.char = &quot;&quot;) # Arrange colors alphabetically colors_alphabetic &lt;- ehi_phylum_colors %&gt;% right_join(mags_table, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() Coloured GTDB 214 phylum tree "],["mag-catalogue.html", "Chapter 3 MAG catalogue 3.1 MAG phylogeny 3.2 MAG quality 3.3 Functional attributes of MAGs 3.4 Functional ordination of MAGs", " Chapter 3 MAG catalogue This workflow explores the characteristics of the MAG catalogue generated through the EHI pipeline. Note the workflow begins where the General analysis pipeline ends, so make sure you go through the general pipeline before starting working on this document. 3.1 MAG phylogeny You can visualise the phylogeny of MAGs in multiple ways. Here we describe a workflow to generate a circular plot with a bunch of relevant information in outer rings. Prepare MAG metadata First, we need to prepare the MAG metadata we want to plot in the outer rings of the tree. # Which phylum the MAG belongs to phyla &lt;- ehi_phylum_colors %&gt;% right_join(mags_table, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() # What is the genome size of the MAG in MBs (megabases) mag_sizes &lt;- mags_table %&gt;% select(c(genome,mag_size)) %&gt;% mutate(mag_size=round(mag_size/1000000,2)) # What is the completeness of the MAG mag_completeness &lt;- mags_table %&gt;% select(c(genome,completeness)) %&gt;% as.data.frame() %&gt;% remove_rownames() %&gt;% column_to_rownames(var = &quot;genome&quot;) # Generate the phylum color heatmap heatmap &lt;- ehi_phylum_colors %&gt;% right_join(mags_table, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, tree$tip.label)) %&gt;% select(genome,phylum) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) Plot phylogenetic tree The next step is to plot the actual tree. # Create baseline circular tree circular_tree &lt;- force.ultrametric(tree,method=&quot;extend&quot;) %&gt;% ggtree(., layout = &#39;circular&#39;, size = 0.3, angle=45) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultramtric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # Add phylum colors ring circular_tree &lt;- gheatmap(circular_tree, heatmap, offset=0.85, width=0.1, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic) + geom_tiplab2(size=1, hjust=-0.1) + theme(legend.position = &quot;none&quot;, plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0)) # Flush color scale to enable a new color scheme in the next ring circular_tree &lt;- circular_tree + new_scale_fill() # Add completeness ring circular_tree &lt;- circular_tree + new_scale_fill() + scale_fill_gradient(low = &quot;#d1f4ba&quot;, high = &quot;#f4baba&quot;) + geom_fruit( data=mags_table, geom=geom_bar, mapping = aes(x=completeness, y=genome, fill=contamination), offset = 0.55, orientation=&quot;y&quot;, stat=&quot;identity&quot;) # Add genome-size ring circular_tree &lt;- circular_tree + new_scale_fill() + scale_fill_manual(values = &quot;#cccccc&quot;) + geom_fruit( data=mag_sizes, geom=geom_bar, mapping = aes(x=mag_size, y=genome), offset = 0.05, orientation=&quot;y&quot;, stat=&quot;identity&quot;) #Plot circular tree circular_tree Plot phylum color legend You can also create a custom phylum color legend using the following code. # Create legend phyla_legend &lt;- ehi_phylum_colors %&gt;% right_join(mags_table, by=join_by(phylum == phylum)) %&gt;% arrange(match(genome, tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% mutate(phylum = gsub(&quot;p__&quot;,&quot;&quot;,phylum)) %&gt;% mutate(phylum = factor(phylum, levels = phylum)) %&gt;% ggplot() + geom_blank() + geom_rect(aes(xmin = 1:(nrow(phyla)) - 0.5, xmax = 1:(nrow(phyla)) + 0.5, ymin = 0.19, ymax = 0.2, fill = phylum)) + scale_fill_manual(values=rev(phyla$colors)) + geom_text(aes(x = 1:(nrow(phyla)), y = 0.15, label = rev(phylum)), angle = 90, hjust = 0, size = 3) + theme_void() + theme(legend.position = &quot;none&quot;) # Plot legend phyla_legend 3.2 MAG quality You can next plot a 2-dimensional plot showing the two main parameters used to assess quality of reconstructed MAG: completeness and contamination (or redundancy). These parameters are calculated by CheckM based on the presence of single-copy core genes in the MAGs. Completeness values should ideally be as close to 100 as possible, because incompleteness introduces biases when performing functional analyses. Contamination should be as close to 0 as possible, because it indicates that the MAG probably contains DNA fragments that in reality belong to a different genome, and therefore can distort the results and introduce noise. Prepare input table You first need to prepare the input table from the original MAG metadata table. mag_details &lt;- mags_table %&gt;% select(c(genome,domain,phylum,completeness,contamination,mag_size)) %&gt;% mutate(mag_size=round(mag_size/1000000,2)) %&gt;% #change mag_size to MBs rename(comp=completeness,cont=contamination,size=mag_size) %&gt;% #rename columns remove_rownames() %&gt;% arrange(match(genome, rev(tree$tip.label))) #sort MAGs according to phylogenetic tree Create biplot chart Using the code below you can create a plot in which MAGs are ordinated according to their completeness and contamination scores, while dot sizes indicate their genome-size. mag_stats_biplot &lt;- mag_details %&gt;% ggplot(aes(x=comp,y=cont,size=size,color=phylum)) + geom_point(alpha=0.7) + ylim(c(10,0)) + scale_color_manual(values=colors_alphabetic) + labs(y= &quot;Contamination&quot;, x = &quot;Completeness&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) Create boxplot charts You can also create X and Y axis boxplots to complement the above plot and better visualise MAG quality statistics. mag_stats_cont &lt;- mag_details %&gt;% ggplot(aes(y=cont)) + ylim(c(10,0)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0.40, 0),&quot;inches&quot;)) #add bottom-margin (top, right, bottom, left) mag_stats_comp &lt;-mag_details %&gt;% ggplot(aes(x=comp)) + xlim(c(50,100)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0, 0.50),&quot;inches&quot;)) #add left-margin (top, right, bottom, left) Create composite figure Finally, you can plot a composite figure containing all above charts. The complex layout matrix only defines the space of each plot in the composite figure. grid.arrange(grobs = list(mag_stats_comp,mag_stats_biplot,mag_stats_cont), layout_matrix = rbind(c(1,1,1,1,1,1,1,1,1,1,1,4), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3), c(2,2,2,2,2,2,2,2,2,2,2,3))) 3.3 Functional attributes of MAGs Prokaryotic genomes carry different sets of genes that confer their organisms with different functional capabilities By annotating the microbial genes against the KEGG database, enables calculating how full each of the hundreds of metabolic functions is in each genome, and in this way infer functional capabilities of each MAG. Using the code below, you can create a heatmap with an associated phylogenetic tree showing how the MAG phylogenetic tree is associated with fullness (between 0-1) levels for each metabolic pathway. #Generate a basal utrametric tree for the sake of visualisation kegg_tree &lt;- force.ultrametric(tree,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultramtric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** #Add phylum colors next to the tree tips kegg_tree &lt;- gheatmap(kegg_tree, heatmap, offset=0, width=0.1, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic) #Reset fill scale to use a different colour profile in the heatmap kegg_tree &lt;- kegg_tree + new_scale_fill() #Add KEGG heatmap kegg_tree &lt;- gheatmap(kegg_tree, kegg_table, offset=0.5, width=3.5, colnames=FALSE) + vexpand(.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) #Plot combined tree + heatmap kegg_tree + theme(legend.position=&#39;none&#39;) 3.4 Functional ordination of MAGs Using the functional annotation, it is possible to ordinate prokaryotic genomes on a bidimentional space. In doing so, one can assess how close any group of bacteria are in functional terms, or how functionally diverse the members of a given phylum can be. In this example the ordination is conducted using the tSNE method. # Generate the tSNE ordination tSNE_func &lt;- Rtsne(X=kegg_table, dims = 2, check_duplicates = FALSE) # Plot the ordination tSNE_func$Y %&gt;% as.data.frame() %&gt;% mutate(genome=rownames(kegg_table)) %&gt;% inner_join(mags_table, by=&quot;genome&quot;) %&gt;% rename(tSNE1=&quot;V1&quot;, tSNE2=&quot;V2&quot;) %&gt;% select(genome,phylum,tSNE1,tSNE2, completeness) %&gt;% ggplot(aes(x = tSNE1, y = tSNE2, color = phylum, size=completeness))+ geom_point(shape=16, alpha=0.7) + scale_color_manual(values=colors_alphabetic) + theme_minimal() + theme(legend.position = &quot;none&quot;) "],["sequencing-assessment.html", "Chapter 4 Sequencing Assessment 4.1 DNA fractions 4.2 Estimated vs. mapped prokaryotic fraction 4.3 Additional sequencing needed", " Chapter 4 Sequencing Assessment This workflow explores the characteristics of the MAG catalogue generated through the EHI pipeline. Note the workflow begins where the General analysis pipeline ends, so make sure you go through the general pipeline before starting working on this document. 4.1 DNA fractions When performing genome-resolved metagenomic analyses on host-associated microbial communities, the data usually contains a mixture of origins. One fraction is low-quality data that is discarded in the bioinformatic preprocessing due to lack of informativeness. These data include low-quality bases, adaptors, low-complexity reads and alike, which do not contribute to the study. Another fraction belongs to the host genome against which the data are mapped. The host fraction can be very variable depending on the species and the sample type, and while it is not informative for metagenomic analyses, it can be used for genomic analyses. The rest is what we call the metagenomic fraction. Part of the metagenomic fraction is built into draft bacterial genomes or MAGs, against which metagenomic reads are mapped later on to quantify relative representation of genomes. The fraction that is not built into MAGs is what is also unmapped against the MAG catalogue. This last fraction includes DNA dietary items, viruses and other organisms, but can include prokaryotic DNA of bacteria and archaea that were unable to be reconstructed. In order to have representative results, the number of reads mapped to the MAG catalogue should be similar across samples. However, multiple reasons can create large imbalances, including uneven sequencing depth, different microbiome complexity across samples, different amount of host or non-microbial reads in the dataset, etc. The following scripts generate a plot showing the distribution of reads across samples. sequence_fractions &lt;- count_table %&gt;% rownames_to_column(&quot;Genome&quot;) %&gt;% pivot_longer(-Genome, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) %&gt;% group_by(sample) %&gt;% summarise(mags = sum(value)) %&gt;% left_join(sample_table, by = join_by(sample == sample)) %&gt;% select(sample,mags,metagenomic_bases,host_bases,bases_lost_fastp_percent) %&gt;% mutate(mags_bases = mags*146) %&gt;% mutate(lowqual_bases = ((metagenomic_bases+host_bases)/(1-bases_lost_fastp_percent))-(metagenomic_bases+host_bases)) %&gt;% mutate(unmapped_bases = metagenomic_bases - mags_bases) %&gt;% mutate(unmapped_bases = ifelse(unmapped_bases &lt; 0, 0, unmapped_bases)) %&gt;% select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases) mags_bases_mean &lt;- sequence_fractions %&gt;% mutate(mags_bases = mags_bases / 1000000000) %&gt;% select(mags_bases) %&gt;% pull() %&gt;% mean() sequence_fractions %&gt;% pivot_longer(!sample, names_to = &quot;fraction&quot;, values_to = &quot;value&quot;) %&gt;% mutate(value = value / 1000000000) %&gt;% mutate(fraction = factor(fraction, levels = c(&quot;lowqual_bases&quot;,&quot;host_bases&quot;,&quot;unmapped_bases&quot;,&quot;mags_bases&quot;))) %&gt;% ggplot(., aes(x = sample, y = value, fill=fraction)) + geom_bar(position=&quot;stack&quot;, stat = &quot;identity&quot;) + scale_fill_manual(values=c(&quot;#CCCCCC&quot;,&quot;#178a94&quot;,&quot;#ee8080&quot;,&quot;#d03161&quot;)) + geom_hline(yintercept = mags_bases_mean, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + labs(x = &quot;Samples&quot;, y = &quot;Amount of data (GB)&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = &quot;bottom&quot;) 4.2 Estimated vs. mapped prokaryotic fraction The main metric employed to assess the representativeness of a prokaryotic community using genome-resolved metagenomics is to measure the percentage or reads mapped to the MAG catalogue. This metric, however can be slippery when prokaryotic DNA is not dominant in the metagenomic mixture. Host DNA, dietary DNA, viral DNA and other non-prokaryotic DNA sequences can drastically underestimate representativeness in such cases. In the EHI we also employ another metric which estimated the proportion of prokaryotic sequences in a sample relying on coverage values on marker genes and extrapolation of genome sizes of the closest relatives. Combining both approaches, we can better estimate whether a prokaryotic community has been properly represented, or whether further sequencing is required. The following script generate a plot in which the difference between estimated vs. mapped prokaryotic fractions can be visualised. A longer the orange line indicates that the mapping rate is further away from the expected fraction of prokaryotic DNA. The absence of lines and brown dots indicate that the mapping rate and the estimated fraction match, so the representativeness is correct. When the mapping value is at zero, it indicates that not enough metagenomic data was generated for this type of analyses, usually due to excessive host DNA. singlem_table &lt;- sequence_fractions %&gt;% mutate(mags_proportion = round((mags_bases / (mags_bases + unmapped_bases))*100,2)) %&gt;% left_join(sample_table, by = join_by(sample == sample)) %&gt;% mutate(singlem_proportion = round(singlem_fraction*100,2)) %&gt;% select(sample,mags_proportion,singlem_proportion) %&gt;% mutate(mags_proportion = ifelse(singlem_proportion == 0, 0, mags_proportion)) %&gt;% #convert zeros to NA mutate(singlem_proportion = ifelse(singlem_proportion == 0, NA, singlem_proportion)) %&gt;% #convert zeros to NA mutate(singlem_proportion = ifelse(singlem_proportion &lt; mags_proportion, NA, singlem_proportion)) %&gt;% #if singlem is smaller, then NA, to simplify plot mutate(singlem_proportion = ifelse(singlem_proportion &gt; 100, 100, singlem_proportion)) #simplify singlem_table %&gt;% pivot_longer(!sample, names_to = &quot;proportion&quot;, values_to = &quot;value&quot;) %&gt;% mutate(proportion = factor(proportion, levels = c(&quot;mags_proportion&quot;,&quot;singlem_proportion&quot;))) %&gt;% ggplot(., aes(x = value, y = sample, color=proportion)) + geom_line(aes(group = sample), color = &quot;#f8a538&quot;) + geom_point() + scale_color_manual(values=c(&quot;#52e1e8&quot;,&quot;#876b53&quot;)) + theme_classic() + labs(y = &quot;Samples&quot;, x = &quot;Prokaryotic fraction (%)&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = &quot;right&quot;) 4.3 Additional sequencing needed Estimating the amount of host and metagenomic data required for robust hologenomic analyses is very complex, because these values are dependent on many system and study-specific factors. Here you will find the minimum data requirements that work for most systems, which take as reference a desired amount of 5GB of host DNA and 2GB of prokaryotic DNA. The calculations of extra sequencing required take into account the different fractions of sequencing data, including low-quality, host, MAG catalogue-mapped and other metagenomic reads. The bars exceeding the vertical dashed bar set at 20GB of data indicate that more than 20GBs are required to reach the desired amount of host or prokaryotic data. You can check the table for the actual value, but bear in mind that generating more than 20GB of data is economically prohibitive in most cases. # Define the aimed GBs for host and mapped metagenomic data mags_bases_aim=2 host_bases_aim=5 sequence_fractions_required &lt;- sequence_fractions %&gt;% mutate(mags_bases = round(mags_bases / 1000000000,2)) %&gt;% mutate(unmapped_bases = round(unmapped_bases / 1000000000,2)) %&gt;% mutate(host_bases = round(host_bases / 1000000000,2)) %&gt;% mutate(lowqual_bases = round(lowqual_bases / 1000000000,2)) %&gt;% mutate(total_bases = mags_bases+unmapped_bases+host_bases+lowqual_bases) %&gt;% mutate(mags_bases_fraction = mags_bases/total_bases) %&gt;% mutate(mags_bases_difference = mags_bases_aim - mags_bases) %&gt;% mutate(meta_required = round(mags_bases_difference / mags_bases_fraction,2)) %&gt;% mutate(meta_required = ifelse(meta_required &lt; 0, 0, meta_required)) %&gt;% mutate(host_bases_fraction = host_bases/total_bases) %&gt;% mutate(host_bases_difference = host_bases_aim - host_bases) %&gt;% mutate(host_required = round(host_bases_difference / host_bases_fraction,2)) %&gt;% mutate(host_required = ifelse(host_required &lt; 0, 0, host_required)) %&gt;% select(sample,mags_bases,unmapped_bases,host_bases,lowqual_bases,meta_required,host_required) sequence_fractions_required %&gt;% select(sample,meta_required,host_required) %&gt;% mutate(meta_required = ifelse(meta_required &gt; 20, 21, meta_required)) %&gt;% mutate(host_required = ifelse(host_required &gt; 20, 21, host_required)) %&gt;% pivot_longer(!sample, names_to = &quot;requirement&quot;, values_to = &quot;value&quot;) %&gt;% mutate(requirement = factor(requirement, levels = c(&quot;host_required&quot;,&quot;meta_required&quot;))) %&gt;% ggplot(., aes(x = value, y = sample, fill=requirement, group=requirement)) + geom_bar(position=&quot;stack&quot;, stat = &quot;identity&quot;) + scale_fill_manual(values=c(&quot;#178a94&quot;,&quot;#d03161&quot;)) + facet_wrap(~requirement, scales=&quot;free_x&quot;) + labs(x = &quot;Amount of data (GB)&quot;, y = &quot;Samples&quot;) + geom_vline(xintercept = 20, linetype = &quot;dashed&quot;, color = &quot;black&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size=6),legend.position = &quot;bottom&quot;) "],["count-data.html", "Chapter 5 Count data 5.1 Minimum coverage filtering 5.2 Genome size normalisation 5.3 Count table", " Chapter 5 Count data This workflow transforms and visualises the quantitative information of the MAGs generated through the EHI pipeline. Note the workflow relies on previous scripts, so make sure you go through the general pipeline before starting working on this document. 5.1 Minimum coverage filtering Mapping of sequencing reads against the reference genome catalogue is not perfect, and in consequence, all MAGs tend to get a few reads assigned. Implementing a minimum genome coverage filter aims at minimising artificial inflation of diversity due to this artefact of genome-resolved metagenomic analysis. The EHI pipeline implements a default coverage threshold of 0.3 (%30) of a genome. However, if the sequencing depth is low and uneven across samples, this filtering can also introduce distortion, by introducing false positives. min_coverage=0.3 count_table_cov &lt;- coverage_table %&gt;% mutate(across(everything(), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% map2_df(., count_table, ~ .x * .y) %&gt;% as.data.frame() rownames(count_table_cov) &lt;- rownames(coverage_table) 5.2 Genome size normalisation Bacterial genomes can vary between 1 and 8 MB, which make relative representation of each genome dependent on its size. To account for genome size biases, read-counts can be normalised by applying a normalisation factor that modifies the read numbers according to the size of each genome compared to the average genome size in the dataset. genome_read_sizes &lt;- mags_table[rownames(count_table_cov),] %&gt;% select(mag_size) %&gt;% mutate(mag_size = mag_size / 150) %&gt;% pull() count_table_cov_size &lt;- sweep(count_table_cov, 1, genome_read_sizes, &quot;/&quot;) 5.3 Count table Once low-coverage genome counts have been filtered out, and the read counts have been normalised into genome counts, we can visualise the relative MAG abundances per sample. Note that the script shown below generates a count table in which the scale is log-transformed. vertical_tree &lt;- force.ultrametric(tree,method=&quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultramtric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** #Add phylum colors vertical_tree &lt;- gheatmap(vertical_tree, heatmap, offset=0, width=0.1, colnames=FALSE) + scale_fill_manual(values=colors_alphabetic) #Reset fill scale vertical_tree &lt;- vertical_tree + new_scale_fill() #Add counts vertical_tree &lt;- gheatmap(vertical_tree, log10(count_table_cov_size), offset=0.04, width=3.5, colnames=TRUE, colnames_angle=90, font.size=2, colnames_position=&quot;top&quot;, colnames_offset_y = 9) + vexpand(.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) #Plot tree vertical_tree + theme(legend.position=&#39;none&#39;) We can then plot a legend for the count data. #Add count scale countscale &lt;- seq(log(max(count_table_cov_size)), 0, length.out = 5) count_legend &lt;- data.frame(value = countscale, x = c(round(exp(countscale[1]),2),round(exp(countscale[2]),2),round(exp(countscale[3]),2),round(exp(countscale[4]),2),&quot;0&quot;)) %&gt;% mutate(x = factor(x, levels = x)) %&gt;% ggplot(., aes(x = x, y = 0.2)) + geom_tile(aes(fill = value, y = 0.2), color=&quot;#CCCCCC&quot;) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;steelblue&quot;, na.value=&quot;white&quot;) + theme_void() + theme(legend.position=&#39;none&#39;, axis.text.x = element_text(angle = 90, vjust = 1, hjust=1, size=8)) #Arrange both legends grid.arrange(grobs = list(phyla_legend,count_legend), layout_matrix = rbind(c(1,1,2),c(1,1,3))) "],["taxonomic-composition.html", "Chapter 6 Taxonomic composition 6.1 Taxonomy stacked barplot", " Chapter 6 Taxonomic composition This workflow explores the taxonomic characteristics of the MAG catalogue across samples. Note the workflow relies on previous scripts, so make sure you go through the general pipeline before starting working on this document. 6.1 Taxonomy stacked barplot count_table_cov_size_pivot &lt;- count_table_cov_size %&gt;% rownames_to_column(&quot;Genome&quot;) %&gt;% mutate_at(vars(-Genome),~./sum(.)) %&gt;% #apply TSS nornalisation pivot_longer(-Genome, names_to = &quot;sample&quot;, values_to = &quot;count&quot;) %&gt;% #reduce to minimum number of columns left_join(., mags_table, by = join_by(Genome == genome)) %&gt;% #append taxonomy mutate(phylum = fct_relevel(phylum, rev(ehi_phylum_colors$phylum))) #sort phyla by taxonomy # Retrieve taxonomy colors to use standardised EHI colors phylum_colors &lt;- ehi_phylum_colors %&gt;% filter(phylum %in% unique(count_table_cov_size_pivot$phylum)) %&gt;% select(colors) %&gt;% pull() %&gt;% rev() phylum_colors &lt;- c(phylum_colors,&quot;#cccccc&quot;) #REMOVE! ONLY FOR ARCHAEANS # Plot stacked barplot ggplot(count_table_cov_size_pivot, aes(x=sample,y=count,fill=phylum, group=phylum))+ #grouping enables keeping the same sorting of taxonomic units geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1)+ #plot stacked bars with white borders scale_fill_manual(values=phylum_colors) + labs(y = &quot;Relative abundance&quot;) + guides(fill = guide_legend(ncol = 3)) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.x = element_blank(), panel.background = element_blank(), panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(linewidth = 0.5, linetype = &quot;solid&quot;, colour = &quot;black&quot;), legend.position=&quot;none&quot;, legend.title=element_blank()) "],["diversity-analyses.html", "Chapter 7 Diversity analyses 7.1 Data preparation 7.2 Alpha diversity 7.3 Beta diversity", " Chapter 7 Diversity analyses This workflow performs diversity analyses of the count data generated through the EHI pipeline. Note the workflow relies on previous scripts, so make sure you go through the general pipeline before starting working on this document. 7.1 Data preparation In order to avoid issues with diversity computation is recommendable to remove samples and MAGs without count data. #Get list of present MAGs present_MAGs &lt;- count_table_cov_size %&gt;% filter(rowSums(.[, -1]) != 0) %&gt;% rownames() #Remove samples with all zeros (no data after filtering) count_table_cov_size &lt;- count_table_cov_size %&gt;% select_if(~!all(. == 0)) #Align KEGG annotations with present MAGs and remove all-zero and all-one traits present_MAGs &lt;- present_MAGs[present_MAGs %in% rownames(kegg_table)] kegg_table_filt &lt;- kegg_table[present_MAGs,] %&gt;% select_if(~!all(. == 0)) %&gt;% #remove all-zero modules select_if(~!all(. == 1)) #remove all-one modules #Filter count table to only contain present MAGs after KEGG filtering count_table_cov_size_filt &lt;- count_table_cov_size[present_MAGs,] 7.2 Alpha diversity Alpha diversity metrics q0n &lt;- hilldiv(count_table_cov_size,q=0) %&gt;% c() q1n &lt;- hilldiv(count_table_cov_size,q=1) %&gt;% c() q1p &lt;- hilldiv(count_table_cov_size,q=1,tree=tree) %&gt;% c() dist &lt;- traits2dist(kegg_table_filt, method=&quot;gower&quot;) q1f &lt;- hilldiv(count_table_cov_size_filt,q=1,dist=dist) %&gt;% c() # Merge all metrics alpha_div &lt;- cbind(sample=colnames(count_table_cov_size),richness=q0n,neutral=round(q1n,3),phylo=round(q1p,3),func=round(q1f,3)) %&gt;% as.data.frame() columns &lt;- c(&quot;richness&quot;,&quot;neutral&quot;,&quot;phylo&quot;,&quot;func&quot;,&quot;mapped&quot;,&quot;total&quot;) # Add amount of sequencing data to the table alpha_div &lt;- alpha_div %&gt;% left_join(sequence_fractions, by = join_by(sample == sample)) %&gt;% #add sequencing depth information mutate(mapped=round(mags_bases/1000000000,3)) %&gt;% #modify depth to million reads mutate(total=round((mags_bases+unmapped_bases+host_bases+lowqual_bases)/1000000000,3)) %&gt;% select(sample,richness,neutral,phylo,func,mapped,total) %&gt;% mutate(across(-1, as.numeric)) Alpha diversity plots alpha_div %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% ggplot(aes(x=value, y=sample)) + geom_bar(stat=&#39;identity&#39;, fill=&quot;#6c9ebc&quot;) + facet_wrap(~data, scales=&quot;free_x&quot;, ncol=6) + theme_classic() + theme( strip.background = element_blank(), panel.grid.minor.x = element_line( size=.1, color=&quot;grey&quot; ), axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1) ) Warning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0. ℹ Please use the `linewidth` argument instead. This warning is displayed once every 8 hours. Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. You can also generate an HTML table using knitr. kable(alpha_div) sample richness neutral phylo func mapped total EHI00696 190 101.237 10.960 1.518 3.430 5.868 EHI00687 75 51.579 8.942 1.523 0.783 1.297 EHI00757 123 64.415 11.643 1.626 2.567 4.455 EHI00686 82 17.581 6.624 1.373 3.094 4.307 EHI00693 159 72.791 9.241 1.450 3.975 5.656 EHI00697 54 41.198 10.126 1.476 0.386 1.067 EHI00688 114 52.637 7.758 1.485 2.812 3.850 EHI00730 215 113.479 16.288 1.521 2.565 5.078 EHI00692 162 60.243 10.864 1.485 3.244 5.099 EHI00676 159 82.850 10.203 1.469 2.401 3.758 EHI00682 85 46.715 15.128 1.568 0.780 1.596 EHI00679 137 69.732 12.678 1.500 1.645 3.306 EHI00690 95 44.051 8.235 1.420 1.424 2.459 EHI00683 125 81.839 12.258 1.481 1.189 2.022 EHI00733 147 60.117 7.219 1.427 3.688 5.706 EHI00685 89 40.760 8.071 1.491 4.730 6.188 EHI00752 70 41.494 13.077 1.589 3.176 8.595 EHI00681 69 28.127 6.909 1.440 1.093 1.528 EHI00700 144 88.972 11.118 1.473 1.660 2.480 EHI00680 132 65.208 8.859 1.529 2.736 3.559 EHI00751 113 64.296 11.104 1.528 2.999 4.552 EHI00742 113 56.852 9.372 1.505 3.071 5.697 EHI00675 128 65.964 13.873 1.495 1.592 3.102 EHI00732 117 70.557 7.101 1.458 1.360 3.986 EHI00684 120 59.392 9.508 1.436 1.498 3.132 EHI00694 121 46.891 8.820 1.448 3.452 5.636 EHI00743 165 78.383 8.533 1.467 4.395 6.805 EHI00731 144 89.203 9.214 1.537 1.648 2.853 EHI00698 97 20.448 6.877 1.366 1.399 2.199 EHI00699 142 68.270 12.874 1.452 1.931 2.983 EHI00674 60 32.495 6.593 1.410 0.669 1.039 EHI00753 89 55.487 12.870 1.551 1.742 3.324 EHI00695 179 91.539 9.847 1.437 4.036 5.528 EHI00678 135 71.700 10.831 1.466 2.403 3.815 EHI00689 62 20.056 6.318 1.374 1.551 2.029 EHI00677 121 50.998 7.182 1.485 6.818 8.344 EHI00691 81 35.247 8.681 1.441 2.738 3.846 Alpha diversity comparisons Alpha diversities can be compared across any categorical features that group analysed samples (e.g., localities, sampling seasons, sex), or continuous variables associated with the host animals. Let’s first create a nice colour palette for the localities alpha_colors &lt;- c(&quot;#e5bd5b&quot;,&quot;#6b7398&quot;,&quot;#76b183&quot;,&quot;#d57d2c&quot;,&quot;#2a2d26&quot;,&quot;#f9d4cc&quot;,&quot;#3c634e&quot;,&quot;#ea68c3&quot;) Let’s also identify the number of comparing groups, so that the colour palette can be subsetted properly when plotting the figures. group_n &lt;- alpha_div %&gt;% select(sample,neutral) %&gt;% left_join(sample_table, by = join_by(sample == sample)) %&gt;% mutate(location=paste0(round(longitude,2),&quot;_&quot;,round(latitude,2))) %&gt;% select(location) %&gt;% pull() %&gt;% unique() %&gt;% length() Neutral diversity alpha_div %&gt;% select(sample,neutral) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_table, by = join_by(sample == sample)) %&gt;% mutate(location=paste0(round(longitude,2),&quot;_&quot;,round(latitude,2))) %&gt;% ggboxplot(., x = &quot;location&quot;, y = &quot;value&quot;, color = &quot;location&quot;, fill=&quot;location&quot;) + scale_color_manual(values=alpha_colors[c(1:group_n)]) + scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],&quot;50&quot;)) + stat_compare_means() + theme_classic() + labs(y = &quot;Neutral Hill numbers&quot;) + theme( legend.position = &quot;top&quot;, legend.box = &quot;horizontal&quot;, axis.title.x = element_blank(), axis.text.x = element_blank()) + guides(color=guide_legend(title=&quot;Location&quot;), fill=&quot;none&quot;) Phylogenetic diversity alpha_div %&gt;% select(sample,phylo) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_table, by = join_by(sample == sample)) %&gt;% mutate(location=paste0(round(longitude,2),&quot;_&quot;,round(latitude,2))) %&gt;% ggboxplot(., x = &quot;location&quot;, y = &quot;value&quot;, color = &quot;location&quot;, fill=&quot;location&quot;) + scale_color_manual(values=alpha_colors[c(1:group_n)]) + scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],&quot;50&quot;)) + stat_compare_means() + theme_classic() + labs(y = &quot;Phylogenetic Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.text.x = element_blank()) Functional diversity alpha_div %&gt;% select(sample,func) %&gt;% pivot_longer(-sample, names_to = &quot;data&quot;, values_to = &quot;value&quot;) %&gt;% mutate(data = factor(data, levels = columns)) %&gt;% left_join(sample_table, by = join_by(sample == sample)) %&gt;% mutate(location=paste0(round(longitude,2),&quot;_&quot;,round(latitude,2))) %&gt;% ggboxplot(., x = &quot;location&quot;, y = &quot;value&quot;, color = &quot;location&quot;, fill=&quot;location&quot;) + scale_color_manual(values=alpha_colors[c(1:group_n)]) + scale_fill_manual(values=paste0(alpha_colors[c(1:group_n)],&quot;50&quot;)) + stat_compare_means() + theme_classic() + labs(y = &quot;Functional Hill numbers&quot;) + theme( legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.text.x = element_blank()) Relationship between alpha diversity and sequencing effort The microbial diversity in a sample is often correlated with sequencing depth, mainly when the sequencing effort is not large enough to properly capture the entirety of the diversity in the sample. The following plot shows the relationship between neutral diversity (Hill number of q=1, Shannon diversity) and the GBs mapped to the MAG catalogue. The size of the dots indicates the total sequencing effort performed for that sample (including host DNA, non-mapped reads, etc.). The flatter the regression line the lower is the correlation, and thus lower is the effect of sequencing depth in the results. However, it must be noted that this analysis only compares the sequencing depth in relation to the MAG catalogue, which might not be complete or representative of the system. Hence, the results shown here must be interpreted cautiously. 7.3 Beta diversity Pairwise beta diversities quantify the dissimilarity between samples. Within the Hill numbers framework, beta diversities can be calculated for neutral, phylogenetic and functional diversities, at the desired order of diversity (q-value). Often times, beta diversities differ depending on the components of the diversity. For instance, phylogenetic and functional diversities often display lower beta values than neutral diversities due to phylogenetic and functional redundancy of the microbiota (i.e. different yet closely related and functionally similar MAGs replace each other). Pairwise beta diversities can be displayed in a 2-dimensional ordination using NMDS, and can be used to test for compositional differences between variables of interest. Note that outliers (often technical failures) can distort the ordination considerably. Beta diversity test beta_colors &lt;- c(&quot;#e5bd5b&quot;,&quot;#6b7398&quot;,&quot;#76b183&quot;,&quot;#d57d2c&quot;,&quot;#2a2d26&quot;,&quot;#f9d4cc&quot;,&quot;#3c634e&quot;,&quot;#ea68c3&quot;) Df SumOfSqs R2 F Pr(&gt;F) location 6 1.3247170 0.1191033 0.6509051 0.996 sex 1 0.3001424 0.0269853 0.8848571 0.662 Residual 28 9.4975634 0.8539114 NA NA Total 35 11.1224228 1.0000000 NA NA Beta diversity plot group_n &lt;- length(unique(beta_q1n_nmds$region)) beta_q1n_nmds %&gt;% group_by(region) %&gt;% mutate(x_cen = mean(NMDS1, na.rm = TRUE)) %&gt;% mutate(y_cen = mean(NMDS2, na.rm = TRUE)) %&gt;% ungroup() %&gt;% ggplot(., aes(x=NMDS1,y=NMDS2, color=region)) + scale_color_manual(values=beta_colors[c(1:group_n)]) + geom_point(size=2) + geom_segment(aes(x=x_cen, y=y_cen, xend=NMDS1, yend=NMDS2), alpha=0.2) + theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Region&quot;)) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
